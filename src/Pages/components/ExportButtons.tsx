// File: src/components/ExportButtons.tsx
import React from 'react';
import {
  Button,
  Stack,
  Box,
  Typography,
  IconButton,
  Tooltip
} from '@mui/material';
import {
  IconFileTypePdf,
  IconFileTypeXls,
  IconDownload
} from '@tabler/icons-react';
import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import * as XLSX from 'xlsx';
import { useTranslation } from 'react-i18next';
import { useSelector } from 'src/store/Store';
import { AppState } from 'src/store/Store';

// Cairo Base64 modules (generated by your convert-font script)
import { cairoRegularBase64 } from 'src/assets/fonts/Cairo-Regular';
import { cairoBoldBase64    } from 'src/assets/fonts/Cairo-Bold';

import arabicReshaper from 'arabic-reshaper';
import bidiFactory from 'bidi-js';
const bidi = bidiFactory();

interface Column {
  field: string;
  headerName: string;
  width?: number;
  type?: 'string' | 'number' | 'date' | 'boolean';
  format?: (value: any) => string;
}

interface ExportButtonsProps {
  data: any[];
  columns: Column[];
  fileName: string;
  title?: string;
  disabled?: boolean;
  loading?: boolean;
  compact?: boolean;
}

const ExportButtons: React.FC<ExportButtonsProps> = ({
  data,
  columns,
  fileName,
  title,
  disabled = false,
  loading = false,
  compact = false
}) => {
  const { t } = useTranslation();
  const customizer = useSelector((state: AppState) => state.customizer);
  const isRTL = customizer.activeDir === 'rtl';

  const getNested = (obj: any, path: string) =>
    path.split('.').reduce((o, k) => (o && o[k] != null ? o[k] : ''), obj);

  // Prepare rows for Excel/PDF
  const prepareRows = () =>
    data.map(row => {
      const r: Record<string, any> = {};
      columns.forEach(col => {
        let v = getNested(row, col.field);
        if (col.format && v != null) {
          v = col.format(v);
        } else {
          switch (col.type) {
            case 'number':
              v = typeof v === 'number' ? v.toFixed(2) : v || '0.00';
              break;
            case 'date':
              v = v ? new Date(v).toLocaleDateString() : '';
              break;
            case 'boolean':
              v = v ? t('common.yes') : t('common.no');
              break;
            default:
              v = v || '';
          }
        }
        r[col.headerName] = v;
      });
      return r;
    });

  const exportPDF = () => {
    try {
      const doc = new jsPDF({
        orientation: columns.length > 6 ? 'landscape' : 'portrait',
        unit: 'mm',
        format: 'a4'
      });

      // clean out any non-base64 chars
      const reg64  = cairoRegularBase64.replace(/[^A-Za-z0-9+/=]/g, '');
      const bold64 = cairoBoldBase64   .replace(/[^A-Za-z0-9+/=]/g, '');

      // register Cairo fonts
      doc.addFileToVFS('Cairo-Regular.ttf', reg64);
      doc.addFont('Cairo-Regular.ttf', 'Cairo', 'normal');
      doc.addFileToVFS('Cairo-Bold.ttf', bold64);
      doc.addFont('Cairo-Bold.ttf',    'Cairo', 'bold');

      // helper: reshape + bidi
      const shape = (txt: string) =>
        isRTL ? bidi(arabicReshaper.reshape(txt)) : txt;

      // title
      if (title) {
        doc.setFont('Cairo', 'bold');
        doc.setFontSize(16);
        const pw = doc.internal.pageSize.getWidth();
        const x  = isRTL ? pw - 20 : 20;
        doc.text(shape(title), x, 20, { align: isRTL ? 'right' : 'left' });
      }

      // prepare table head & body
      const head = columns.map(c => shape(c.headerName));
      const body = prepareRows().map(r =>
        columns.map(col => shape(String(r[col.headerName])))
      );

      // set default font for body
      doc.setFont('Cairo', 'normal');

      autoTable(doc, {
        head: [head],
        body,
        startY: title ? 30 : 20,
        styles: {
          font: 'Cairo',
          fontStyle: 'normal',
          fontSize: 9,
          cellPadding: 3
        },
        headStyles: {
          font: 'Cairo',
          fontStyle: 'bold',
          fontSize: 10,
          halign: isRTL ? 'right' : 'left',
          fillColor: [66, 139, 202],
          textColor: [255, 255, 255]
        },
        bodyStyles: {
          halign: isRTL ? 'right' : 'left'
        },
        alternateRowStyles: {
          fillColor: [245, 245, 245]
        },
        margin: { top: 15, right: 15, bottom: 15, left: 15 },
        didDrawPage: () => {
          const date   = new Date().toLocaleDateString();
          const footer = `${t('common.exportedOn')}: ${date}`;
          const ph     = doc.internal.pageSize.getHeight();
          doc.setFont('Cairo', 'normal');
          doc.setFontSize(8);
          doc.text(footer, isRTL ? doc.internal.pageSize.getWidth() - 20 : 20, ph - 10);
        }
      });

      doc.save(`${fileName}_${new Date().toISOString().split('T')[0]}.pdf`);
    } catch (err) {
      console.error(err);
      alert(t('export.errorPdf'));
    }
  };

  const exportExcel = () => {
    try {
      const rows    = prepareRows();
      const headers = columns.map(c => c.headerName);
      const aoa     = [headers, ...rows.map(r => headers.map(h => r[h]))];
      const ws      = XLSX.utils.aoa_to_sheet(aoa);

      // column widths
      ws['!cols'] = columns.map(c => ({ wch: Math.max(c.headerName.length + 5, 15) }));

      // style header row
      const range = XLSX.utils.decode_range(ws['!ref'] || 'A1');
      for (let C = range.s.c; C <= range.e.c; C++) {
        const cell = XLSX.utils.encode_cell({ r: 0, c: C });
        if (ws[cell]) {
          ws[cell].s = {
            font: { bold: true, name: 'Tahoma', color: { rgb: 'FFFFFF' } },
            fill: { fgColor: { rgb: '428BCA' } },
            alignment: { horizontal: isRTL ? 'right' : 'left', readingOrder: isRTL ? 2 : 1 }
          };
        }
      }

      // style body rows
      for (let R = 1; R <= range.e.r; R++) {
        for (let C = range.s.c; C <= range.e.c; C++) {
          const cell = XLSX.utils.encode_cell({ r: R, c: C });
          if (ws[cell]) {
            ws[cell].s = {
              ...(ws[cell].s || {}),
              font: { name: 'Tahoma' },
              alignment: { horizontal: isRTL ? 'right' : 'left', readingOrder: isRTL ? 2 : 1 }
            };
          }
        }
      }

      // if title provided, insert above headers
      if (title) {
        XLSX.utils.sheet_add_aoa(ws, [[title]], { origin: 'A1' });
        XLSX.utils.sheet_add_aoa(ws, [[]],       { origin: 'A2' });
        const nr = XLSX.utils.decode_range(ws['!ref']!);
        nr.s.r = 2;
        ws['!ref'] = XLSX.utils.encode_range(nr);
      }

      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'Data');
      wb.Props = {
        Title:       title || fileName,
        Subject:     t('export.subject'),
        Author:      t('export.author'),
        CreatedDate: new Date()
      };
      XLSX.writeFile(wb, `${fileName}_${new Date().toISOString().split('T')[0]}.xlsx`);
    } catch {
      alert(t('export.errorExcel'));
    }
  };

  if (!data.length) return null;

  if (compact) {
    return (
      <Stack direction="row" spacing={1} alignItems="center">
        <Typography variant="caption" color="text.secondary" sx={{ mr: 1 }}>
          <IconDownload size={16} style={{ marginRight: 4, verticalAlign: 'middle' }} />
          {t('export.title')}:
        </Typography>
        <Tooltip title={t('export.pdf')}>
          <IconButton onClick={exportPDF} disabled={disabled || loading} size="small" color="error"  sx={{ border: '1px solid', borderColor: 'error.main', borderRadius: 1, '&:hover': { backgroundColor: 'error.light', color: 'white' } }}>
            <IconFileTypePdf size={18} />
          </IconButton>
        </Tooltip>
        <Tooltip title={t('export.excel')}>
          <IconButton onClick={exportExcel} disabled={disabled || loading} size="small" color="success" sx={{ border: '1px solid', borderColor: 'success.main', borderRadius: 1, '&:hover': { backgroundColor: 'success.light', color: 'white' } }}>
            <IconFileTypeXls size={18} />
          </IconButton>
        </Tooltip>
        <Typography variant="caption" color="text.secondary">
          ({data.length} {t('export.records')})
        </Typography>
      </Stack>
    );
  }

  return (
    <Box>
      <Stack direction="row" spacing={2} alignItems="center" sx={{ mb: 2, flexWrap: 'wrap', gap: 1 }}>
        <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <IconDownload size={20} /> {t('export.title')}
        </Typography>
        <Button
          variant="outlined"
          startIcon={<IconFileTypePdf />}
          onClick={exportPDF}
          disabled={disabled || loading || !data.length}
          color="error"
          size="small"
          sx={{ borderWidth: 2, '&:hover': { borderWidth: 2 } }}
        >
          {t('export.pdf')}
        </Button>
        <Button
          variant="outlined"
          startIcon={<IconFileTypeXls />}
          onClick={exportExcel}
          disabled={disabled || loading || !data.length}
          color="success"
          size="small"
          sx={{ borderWidth: 2, '&:hover': { borderWidth: 2 } }}
        >
          {t('export.excel')}
        </Button>
        <Typography variant="caption" color="text.secondary" sx={{ ml: 2 }}>
          {t('export.recordsCount', { count: data.length })}
        </Typography>
      </Stack>
    </Box>
  );
};

export default ExportButtons;
